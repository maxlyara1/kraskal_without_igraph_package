# Создание матрицы
spis_reb <- matrix(0, ncol = 0, nrow = 18)
v1 <- c(1,1,1,2,2,3,4,4,5,5,6,6,6,7,7,8,8,11)
v2 <- c(2,5,7,3,6,12,5,8,9,10,8,9,11,10,12,10,11,12)
weight <- c(5,2,10,8,12,5,6,11,9,3,3,7,7,4,8,15,4,6)
spis_reb <-cbind(spis_reb, v1, v2, weight)
colnames(spis_reb) <- c("v1", "v2", "weight")

# Использование функции order() для получения индексов строк
order_index <- order(spis_reb[, "weight"])

# Переупорядочивание строк матрицы с использованием индексов в порядке возрасания
sorted_mat <- spis_reb[order_index, ]

# Печать отсортированной матрицы
print(sorted_mat)

kraskal <- function(mat){
  
  # Условие на случай, если задан несвязный граф
  if(length(mat) == 0){
    break
  }
  
  # Создание списка компонент связности
  adcomps <- list()
  N <- max(mat[, 1], mat[, 2])
  for(i in 1:N){
    adcomps <- append(adcomps, i)
  }
  
  # Рассмотрение разных рёбер (Итерирование по mat)
  for (i in 1:nrow(mat)) {
    
    # Делаем удобные названия для рассматриваемых вершин
    node1 <- mat[i, 1]
    node2 <- mat[i, 2]
    
    # Условие остановки на случай, когда останется только одна компонента 
    #связности (минимальное остовное дерево)
    if(length(adcomps) > 1){
      
      # Если элемент 1 и 2 столбца mat содержатся в 
      #разных строках adcomps(в разных компонентах связности), 
      #тогда добавить к элементам из первой строки adcomps другую строку(комп.связ.),
      #удалить её:
      
      # Записываем номера компонент связнности, 
      #в которых содержится 1 и 2 вершина
      # по другому можно было написать через ифы, но применим лямбда функцию
      comp1 <- which(sapply(adcomps, function(x) node1 %in% x))
      comp2 <- which(sapply(adcomps, function(x) node2 %in% x))
      
      # Если node1 и node2 содержатся в разных компонентах связности,
      #то объединяем их и удаляем вторую компоненту связности
      if (comp1 != comp2) {
        adcomps[[comp1]] <- union(adcomps[[comp1]], adcomps[[comp2]])
        adcomps[[comp2]] <- NULL
        cat("Добавляем ребро", node1, "-", node2, "\n")
      }
      
      # Иначе (если они находятся в одной компоненте связности), то ничего не делаем
      
    }
    else{
      return(adcomps[[1]])
    }
  }
}


result <- kraskal(sorted_mat)

cat('Минимальное остовное дерево(MST - minimum spanning tree):', result)

